
import torch
import torchvision

from PIL import Image
from tqdm import tqdm

from dataset import Glint360KSubset_Base


class Glint360KSubset_Flip(Glint360KSubset_Base):

    def __init__(
            self, 
            trans,
            loc):
        
        super().__init__(trans, loc)

    def __getitem__(self, x):

        image_loc = self.items[x]
        image = Image.open(image_loc).convert("RGB")
        image_flip = image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
        return image_loc, self.trans(image), self.trans(image_flip)


def generate_flip_scores(
        fr_model : torch.nn.Module, 
        trans: torchvision.transforms.Compose, 
        loc: str, 
        batch_size: int, 
        sim_func: torch.nn.Module) -> dict:
    """Generates quality scores using horizontal flips as the perturbation of choice.

    Args:
        fr_model (torch.nn.Module): Face Recognition used to generate the pseudo quality labels.
        trans (torchvision.transforms.v2.Compose): Function that prepares images for input to the FR model.
        loc (str): Location of the dataset used to generate the labels over.
        batch_size (int): Batch size.
        sim_func (torch.nn.Module): Similarity function used to compare the features of the original and perturbed images.

    Returns:
        dict: {"Image path": quality_score} values generated by the flipping perturbation. 
    """

    # Prepare FR model
    fr_model.cuda().eval()

    # Get flip specific dataset and construct dataloader
    dataset = Glint360KSubset_Flip(trans, loc)
    dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size)

    flip_results = {}
    # Generate flip scores by comparing original to flipped images using cossim
    with torch.no_grad(), torch.autocast("cuda"):

        for (image_loc_batch, image_batch, flipped_image_batch) in tqdm(dataloader, desc="Generating Flip Scores: "):
            
            base_emb = fr_model(image_batch.cuda()).detach()
            flipped_emb = fr_model(flipped_image_batch.cuda()).detach()

            flip_sims = sim_func(base_emb, flipped_emb).detach().cpu().numpy().tolist()

            flip_results.update(dict(zip(image_loc_batch, flip_sims)))

    return flip_results
